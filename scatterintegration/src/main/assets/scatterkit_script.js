function _sendScatterSimulationRequest(params, methodName) { console.log('params', params);console.log('methodName', methodName);if (navigator.userAgent === 'ANDROID_USER_AGENT') {  console.log('ANDROID');  WebView.pushMessage(JSON.stringify({    'params': params,    'methodName': methodName  }));} else if (navigator.userAgent === 'IOS_USER_AGENT') {  console.log('IOS');  window.webkit.messageHandlers.pushMessage.postMessage(JSON.stringify({    'params': params,    'methodName': methodName  }))}return callbackResult(methodName)}function callbackResult(funcName) {return new Promise((resolve, reject) => {  window[funcName] = function (result) {    resolve(JSON.parse(result));  };});}class ScatterSimulation {constructor() {}requestMsgSignature(params) {  return _sendScatterSimulationRequest(params, 'callbackRequestMsgSignature');}requestSignature(params) {  return _sendScatterSimulationRequest(params, 'callbackRequestSignature');}getAppInfo() {  return _sendScatterSimulationRequest('', 'callbackGetAppInfo');}walletLanguage() {  return _sendScatterSimulationRequest('', 'callbackWalletLanguage');}getEosAccount() {  return _sendScatterSimulationRequest('', 'callbackGetEosAccount');}getWalletWithAccount() {  return _sendScatterSimulationRequest('', 'callbackGetWalletWithAccount');}getEosBalance(params) {  const Jparams = JSON.stringify(params);  return _sendScatterSimulationRequest(Jparams, 'callbackGetEosBalance');}getEosAccountInfo(params) {  const Jparams = JSON.stringify(params);  return _sendScatterSimulationRequest(Jparams, 'callbackGetEosAccountInfo');}getTransactionById(params) {  const Jparams = JSON.stringify(params);  return _sendScatterSimulationRequest(Jparams, 'callbackGetTransactionById');}pushActions(params) {  const serialNumber = params.serialNumber;  const Jparams = JSON.stringify(params);  return _sendScatterSimulationRequest(Jparams, 'callbackPushActions');}pushTransfer(params) {  const serialNumber = params.serialNumber;  const Jparams = JSON.stringify(params);  return _sendScatterSimulationRequest(Jparams, 'callbackPushTransfer');}}const ss = new ScatterSimulation();const Blockchains = {EOS: 'eos',ETH: 'eth',TRX: 'trx'};class Network {constructor(_name = '', _protocol = 'https', _host = '', _port = 0, blockchain = Blockchains.EOS, chainId = '') {  this.name = _name;  this.protocol = _protocol;  this.host = _host;  this.port = _port;  this.blockchain = blockchain;  this.chainId = chainId.toString()}static placeholder() {  return new Network()}static fromJson(json) {  const p = Object.assign(Network.placeholder(), json);  p.chainId = p.chainId ? p.chainId.toString() : '';  return p}isValid() {  return (this.protocol.length && this.host.length && this.port) || this.chainId.length};hostport() {  return `${this.host}${this.port?':':''}${this.port}`}}const BLOCKCHAIN_SUPPORT = 'blockchain_support';class Plugin {constructor(_name = '', _type = '') {  this.name = _name;  this.type = _type}static placeholder() {  return new Plugin()}static fromJson(json) {  return Object.assign(Plugin.placeholder(), json)}isSignatureProvider() {  return this.type === BLOCKCHAIN_SUPPORT}}class PluginRepositorySingleton {constructor() {  this.plugins = []}loadPlugin(plugin) {  if (!this.plugin(plugin.name)) this.plugins.push(plugin)}signatureProviders() {  return this.plugins.filter(plugin => plugin.type === BLOCKCHAIN_SUPPORT)}supportedBlockchains() {  return this.signatureProviders().map(plugin => name)}plugin(name) {  return this.plugins.find(plugin => plugin.name === name)}async endorsedNetworks() {  return await Promise.all(this.signatureProviders().map(async plugin => await plugin.getEndorsedNetwork()))}}const PluginRepository = new PluginRepositorySingleton();const throwNoAuth = () => {};const checkForExtension = (resolve, tries = 0) => {if (tries > 20) return;if (window.scatter.isExtension) return resolve(true);setTimeout(() => checkForExtension(resolve, tries + 1), 100)};class IdentityScatterSimulation {constructor(account) {  this.hash = 'db4960659fb585600be9e0ec48d2e6f4826d6f929c4bcef095356ce51424608d';  this.publicKey = 'EOS5rJZvudjCmunqGd2PtfQTYiYRaQPzb82yXnw5FGjZN3waHrQSY';  this.name = 'EOS_SCATTER_SIMULATION';  this.accounts = [{    name: account,    authority: 'active',    blockchain: 'eos'  }];  this.kyc = false}}class Index {constructor() {  this.isExtension = true;  this.identity = null}loadPlugin(plugin) {  const noIdFunc = () => {    if (!this.identity) throw new Error('No Identity')  };  PluginRepository.loadPlugin(plugin);  if (plugin.isSignatureProvider()) {    this[plugin.name] = plugin.signatureProvider(noIdFunc);    this[plugin.name + 'Hook'] = plugin.hookProvider  }}async isInstalled() {  return new Promise(resolve => {    setTimeout(() => {      resolve(false)    }, 3000);    Promise.race([checkForExtension(resolve)])  })}async connect(pluginName, options) {  return new Promise(resolve => {    if (!pluginName || !pluginName.length) throw new Error('You must specify a name for this connection');    options = Object.assign({      initTimeout: 10000,      linkTimeout: 30000    }, options);    setTimeout(() => {      resolve(false)    }, options.initTimeout);    checkForExtension(resolve)  })}disconnect() {}getIdentity(requiredFields) {  throwNoAuth();  return new Promise((resolve, reject) => {    ss.getEosAccount().then((res) => {      var account = res.data;      const ids = new IdentityScatterSimulation(account);      this.identity = ids;      resolve(ids)    })  })}getIdentityFromPermissions() {  throwNoAuth();  return new Promise((resolve, reject) => {    ss.getEosAccount().then((res) => {      var account = res.data;      const ids = new IdentityScatterSimulation(account);      this.identity = ids;      resolve(ids)    })  })}forgetIdentity() {  throwNoAuth();  return new Promise((resolve, reject) => {    this.identity = null;    resolve(true)  })}authenticate(nonce) {  throwNoAuth();  return new Promise((resolve, reject) => {    ss.getEosAccount().then((res) => {      var account = res.data;      const ids = new IdentityScatterSimulation(account);      this.identity = ids;      resolve(ids)    })  })}getArbitrarySignature(publicKey, data, whatfor = '', isHash = false) {  let params = {    publicKey: publicKey,    data: data,    whatfor: whatfor,    isHash: isHash  };  return new Promise((resolve, reject) => {    let jsonParams = JSON.stringify(params);    let signature;    ss.requestMsgSignature(jsonParams).then((res) => {      signature = res.data;      resolve(signature)    })  })}getPublicKey(blockchain) {  throwNoAuth();  return 0}linkAccount(publicKey, network) {  throwNoAuth();  return 0}hasAccountFor(network) {  throwNoAuth();  return 0}suggestNetwork(network) {  throwNoAuth();  return 0}requestTransfer(network, to, amount, options = {}) {  const payload = {    network,    to,    amount,    options  };  return 0}requestSignature(payload) {  throwNoAuth();  return 0}createTransaction(blockchain, actions, account, network) {  throwNoAuth();  return 0}}const proxy = (dummy, handler) => new Proxy(dummy, handler);let cache = {};class ScatterEOS extends Plugin {constructor() {  super(Blockchains.EOS, BLOCKCHAIN_SUPPORT)}signatureProvider(...args) {  const throwIfNoIdentity = args[0];  return (network, _eos, _options = {}) => {    network = Network.fromJson(network);    if (!network.isValid()) throw Error.noNetwork();    const httpEndpoint = `${network.protocol}` + '://' + `${network.hostport()}`;    const chainId = network.hasOwnProperty('chainId') && network.chainId.length ? network.chainId : _options.chainId;    return proxy(_eos({      httpEndpoint,      chainId    }), {      get(eosInstance, method) {        console.log('method', method, eosInstance);        let returnedFields = null;        return (...args) => {          if (args.find(arg => arg.hasOwnProperty('keyProvider'))) throw Error.usedKeyProvider();          const signProvider = async signargs => {            throwIfNoIdentity();            const requiredFields = args.find(arg => arg.hasOwnProperty('requiredFields')) || {              requiredFields: {}            };            var result = '';            var lostresult = await ss.requestSignature(JSON.stringify(signargs)).then((res) => {              result = res.data.signData;              return ''            });            if (!result) return null;            if (result.hasOwnProperty('signatures')) {              returnedFields = result.returnedFields;              let multiSigKeyProvider = args.find(arg => arg.hasOwnProperty('signProvider'));              if (multiSigKeyProvider) {                result.signatures.push(multiSigKeyProvider.signProvider(signargs.buf, signargs.sign))              }              return result.signatures            }            return result          };          return new Promise((resolve, reject) => {            _eos(Object.assign(_options, {              httpEndpoint,              signProvider,              chainId            }))[method](...args).then(result => {              if (!result.hasOwnProperty('fc')) {                result = Object.assign(result, {                  returnedFields                });                resolve(result);                return              }              const contractProxy = proxy(result, {                get(instance, method) {                  if (method === 'then') return instance[method];                  return (...args) => {                    return new Promise(async (res, rej) => {                      instance[method](...args).then(actionResult => {                        res(Object.assign(actionResult, {                          returnedFields                        }))                      }).catch(rej)                    })                  }                }              });              resolve(contractProxy)            }).catch(error => reject(error))          })        }      }    })  }}}function inject() {console.log('inject');window.scatter = new Index();window.scatter.loadPlugin(new ScatterEOS());document.dispatchEvent(new CustomEvent('scatterLoaded'))}inject();";document.getElementsByTagName('head')[0].appendChild(script);